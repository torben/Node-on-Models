// Generated by CoffeeScript 1.6.3
var DB, async, db, fs, sqlite3;

fs = require('fs');

sqlite3 = require('sqlite3').verbose();

async = require('async');

DB = (function() {
  DB.prototype.migrationDir = "./db/migrations";

  DB.prototype.checkTableSql = "SELECT name FROM sqlite_master WHERE type='table' AND name=?;";

  function DB(env, unlink, withMigrations) {
    var file;
    if (env == null) {
      env = 'development';
    }
    if (unlink == null) {
      unlink = false;
    }
    if (withMigrations == null) {
      withMigrations = false;
    }
    this.database = "./db/database_" + env + ".sqlite";
    if (fs.existsSync(this.database) && unlink) {
      fs.unlinkSync(this.database);
    }
    if (!fs.existsSync(this.database)) {
      file = fs.openSync(this.database, 'w');
      fs.close(file);
    }
    this.db = new sqlite3.Database(this.database);
    if (withMigrations) {
      this.doMigrations();
    }
  }

  DB.prototype.loadFieldsFor = function(tableName, callback) {
    var sql;
    sql = "PRAGMA table_info(" + tableName + ");";
    return this.db.all(sql, function(err, result) {
      if (err != null) {
        callback.call(this, err);
      }
      return callback.call(this, null, result.map(function(obj) {
        return obj.name;
      }));
    });
  };

  DB.prototype.doMigrations = function(files) {
    var fns, parseMigrationFile, _file, _i, _len,
      _this = this;
    if (files == null) {
      files = [];
    }
    if (files.length === 0) {
      files = fs.readdirSync(this.migrationDir);
    }
    parseMigrationFile = function() {
      var callback, file, index, migration;
      if (typeof arguments[0] === "function") {
        callback = arguments[0];
        index = 0;
      } else {
        index = arguments[0];
        callback = arguments[1];
      }
      file = files[index];
      migration = require("../" + _this.migrationDir + "/" + file);
      return _this.executeMigration(migration, callback, index);
    };
    fns = [];
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      _file = files[_i];
      fns.push(parseMigrationFile);
    }
    return async.waterfall(fns, function() {
      return console.log("Migration passed!");
    });
  };

  DB.prototype.executeMigration = function(migration, callback, index) {
    var sql,
      _this = this;
    if (callback == null) {
      callback = null;
    }
    if (index == null) {
      index = 0;
    }
    sql = "";
    switch (migration.action) {
      case "createTable":
        return this.db.get(this.checkTableSql, migration.tableName, function(err, row) {
          var field, _i, _len, _ref;
          if ((err != null) || (row != null)) {
            callback.call(_this, err);
            return;
          }
          sql = "CREATE TABLE " + migration.tableName + "(id INTEGER PRIMARY KEY";
          _ref = migration.fields;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            field = _ref[_i];
            sql += "," + field.name + " ";
            sql += (function() {
              switch (field.type) {
                case "string":
                  return "VARCHAR(255)";
                case "integer":
                  return "INTEGER";
                case "text":
                  return "TEXT";
                default:
                  throw new Error("Field type not supported.");
              }
            })();
          }
          sql += ");";
          return _this.db.run(sql, function() {
            if (callback != null) {
              return callback(null, index + 1);
            }
          });
        });
    }
  };

  return DB;

})();

module.exports = DB;

if (require.main === module) {
  db = new DB('development', true, true);
}
